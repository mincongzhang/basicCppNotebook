## 运算符重载\(Operator overloading\)

1.运算符重载实质上是函数重载

```
返回值类型 operator 运算符(形参表){

}
```

2.编译时：  
\(1\)把含有运算符的表达式，转换成对运算符函数的调用  
\(2\)把运算符操作数，当成运算符函数的参数

3.可以重载为普通函数

```
Complex operator+(const Complex & c1, const Complex & c2){
  return Complex(c1.real+c2.real,c1.imag+c2.imag);
}

c = a + b;
c = operator+(a,b);
```

4.也可以重载为成员函数

```
class Complex{
private:
  int real;
  int imag;

public:
  Complex operator+(const Complex & c){
    return Complex(real+c.real,imag+c.imag);
  }
  Complex operator-(const Complex & c){
    //...
  } 
};
```

### 赋值运算符重载

1. 有时候赋值运算符两边类型不匹配，就要重载
2. 只能重载为成员函数

3. 例子\(string类\)

```
#include <iostream>
#include <cstring>


class String{
private:
  char * m_str;
public:
  String(): m_str(NULL){} //构造函数，初始化str为NULL  
  const char * c_str(){return m_str;}
  char * operator=(const char * s);
  ~String();
};


char * String::operator=(const char * s){
  if(m_str) delete [] m_str;

  if(s){ //s不为NULL才执行copy  
    m_str = new char[strlen(s)+1]; //add a place for \0 (which is the end of the string)
    strcpy(m_str,s);
  } else {
    m_str = NULL;
  }

  return m_str;
}

String::~String(){
  if(m_str) delete [] m_str;
}

int main(){
  String s;
  s = "Good Luck";
  std::cout<<s.c_str()<<std::endl;
  //String s2 = "hello"; 会出错, 是初始化语句，会调用构造函数  
  s = "Changed";
  std::cout<<s.c_str()<<std::endl;
  return 0;
}
```

1. 重载赋值运算符的意义-浅复制和深赋值  
   \(1\)浅复制/浅拷贝  
   执行逐个字节的复制工作（指针复制）  
   指针问题（两个指针指向了同一个字串，删除的时候重复删除）  
   \(2\)深复制/深拷贝  
   将一个对象中指针变量指向的内容，复制到另一个对象中指针成员对象指向的地方  
   添加成员函数  

```
String & operator=(const String &s){  
    if(m_str) delete [] m_str;  
    str=new char[strlen(s.m_str)+1];  
    strcpy(m_str,s.m_str);  
    return * this;  
}  
```

operator=返回值类型讨论  
\(1\)返回void好不好？  
考虑a=b=c;  
a.operator=\(b.operator=\(c\)\);  
\(2\)返回String好不好？  
为什么是String &  
尽量保留运算符原本的特性  
考虑\(a=b\)=c;

1. 复制构造函数  
   \(1\)会遇到同样的问题

```
String::String(String & s){
    if(s.m_str){    
        str = new char[strlen(s.m_str)+1];    
        strcpy(m_str,s.m_str);    
    }    
    else m_str = NULL;    
}  
```

2.最终结果

```
#include <iostream>
#include <cstring>


class String{
private:
  char * m_str;
public:
  String(): m_str(NULL){}
  String(const String & s);
  const char * c_str(){return m_str;}
  char * operator=(const char * s);
  ~String();
};

String::String(const String & s){
  if(s.m_str){
    m_str = new char[strlen(s.m_str)+1];
    strcpy(m_str,s.m_str);
  }
  else m_str = NULL;
}


char * String::operator=(const char * s){
  if(m_str) delete [] m_str;

  if(s){
    m_str = new char[strlen(s)+1]; //add a place for \0 (which is the end of the string)
    strcpy(m_str,s);
  } else {
    m_str = NULL;
  }

  return m_str;
}

String::~String(){
  if(m_str) delete [] m_str;
}

int main(){
  String s;
  s = "Good Luck";
  std::cout<<s.c_str()<<std::endl;
  s = "Changed";
  std::cout<<s.c_str()<<std::endl;

  String copy(s);
  std::cout<<copy.c_str()<<std::endl;
  return 0;
}
```

1. 反正就是用引用&拷贝，而不是指针\*拷贝咯



