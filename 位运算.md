## 位运算\(Bitwise operation\)

### 1.单/双目运算符：

\(1\)运算所需变量为一个的运算符叫做单目运算符, 比如!,~,\(\),++,--

\(2\)运算所需变量为两个的运算符叫做双目运算符,比如+,-,\*,/

### 2.十六进制\(Hex or base-16\)和二进制\(Binary or base-2\)

\(1\)以32位int做例子

```
十进制:4294967040
二进制: 1111 1111 1111 1111 1111 1111 0000 0000
十六进制: 0xffffff00

0xffffff00表示低八位全是0，剩下的是1(16进制表示的二进制)
```

\(2\)为什么有时候用十六进制呢?

一般计算机使用二进制, 但是二进制数显示起来太长了. 而且面对这么长的数进行思考或操作, 没有人会喜欢.因此, C, C++ 没有提供在代码直接写二进制数的方法. 用16进制或8进制可以解决这个问题.

### 3.按位"与": &

对应的两个二进位均为1的时候, 结果的对应二进位才为1, 否则为0.

### 3.按位"或": \|

对应的两个二进位均为0的时候, 结果的对应二进位才为0, 否则为1.

### 3.按位"异或": ^

对应的两个二进位不相同的时候, 结果的对应二进位才为1, 否则为0.

一个神奇例子：  
\(1\)简单的加密解密：a^b=c,可以推出c^a=b,c^b=a  
\(2\)不用临时变量，交换两个变量的值：

```
int a=5,b=7;
a=a^b;
b=b^a;
a=a^b;
```

或者按我的理解

```
a=a^b;
b=a^b;
a=a^b;
```

### 3.按位"非": ~

二进制0变1, 1变0

### 4.左移运算符

a&lt;&lt;b

表示的是, 将a各二进位全部左移b位后得到的值. 左移时, 高位丢弃, 低位补0. a的值不因运算而改变.

\(1\)例子: 9&lt;&lt;4, 得到144

0000 0000 0000 0000 0000 0000 0000 1001

0000 0000 0000 0000 0000 0000 1001 0000

\(2\)实际上, 左移1位, 就等于是乘以2, 左移n位,就等于乘以2^n. 左移操作比乘法操作快得多. \(为什么呢\)

二进制的乘法和除法也是用加法减法来代替的. 细节如下

> 当我们在十进制中计算z=x\*y时，我们可以将它转化成z=x+x+…+x\(y个\)来计算，其实在二进制中，我们也是这样计算的。不过对于用二进制表达的数来说，其乘法规则更为简单一些：从乘法y 的最低位开始，若这一位为“1”，则将被乘数x 写下；若这一位为“0”，则写下全0。然后再对乘数y的高一位进行的乘法运算，其规则同上，不过这一位乘数的权与最低位乘数的权不一样，因此被乘数x 要左移一位。依次类推，直到乘数各位乘完为止，最后将它们统统加起来，便得到最后乘积z

例子:

十进制:2 \* 3 = 6

二进制:10 \* 11 = 10 + 100 = 110

\(3\)最后&lt;&lt;=可以直接改变原变量

### 5.右移运算符

a&gt;&gt;b

表示的是, 将a各二进位全部右移b位后得到的值. 右移时, 移出最右边的位就被丢弃. a的值不因运算而改变.

\(1\)对于有符号数, 如long, int, short, char类型的变量, 在右移时, 符号位\(即最高位\)将一起移动, 并且大多数C/C++编译器规定, **如果原符号位为1, 则右移时高位就补充1**, 原符号位为0, 则右移时高位补充0

\(对于“原符号位为1, 则右移时高位就补充”我的理解:负数的符号位为1, 然后剩下的都是补码, 所以补1说的通\)

\(再说到补码, 如果不清楚的话可以搜索二进制补码, 以及二进制负数参考\)

\(2\)同样, 右移n位也就相当于除以2^n, 而且往小取整

\(3\)最后&gt;&gt;=可以直接改变原变量

