### 构造函数\(Constructor\)

1.名字与类名相同, 可以有参数, 不能有返回值\(void 也不行\)

2.作用: 初始化对象, e.g.给成员变量赋初值

3.定义时没写, 编译器生成默认构造函数, 默认构造函数无参数, 不作任何操作

4.基本概念  
\(1\)存储空间不是由构造函数分配, 构造函数只是在已有存储空间的基础上做初始化工作, “对已有房子的装修”  
\(2\)对象生成时构造函数\(默认或自定义\)自动被调用. 生成后, 不能再执行构造函数  
\(3\)一个类可以有多个构造函数

5.为什么需要构造函数:  
执行必要的初始化工作, 有了构造函数, 就不必专门写初始化函数, 不用担心忘记调用初始化函数.

\(有时没初始化会出错\)

\(有时候你想确保初始一个对象的时候, 必须给某些成员变量赋值,比如有一个”人“的类, 初始话的时候必须要设定这个"人"的名字, 这时候就要自己写构造函数\)

6.例子

```
 class Complex{  
     private:  
         double real,imag;  
     public:  
         Complex(double r,double i=0);  
};  
 Complex::Complex(double r,double i){  
     real = r;imag = i;  
}  
 Complex c1;//error,缺少构造函数参数   
 Complex * pc = new Complex;//error   
 Complex C1(2);//correct   
 Complex c1(2,4);//correct   
 Complex * pc = new Complex(3,4);//correct  
```

7.多个构造函数

```
 class Complex{  
     private:  
         double real,imag;  
     public:  
         void Set(double r,doublr i);  
         Complex(double r,double i);  
         Complex(double r);  
         Complex(Complex c1,Complex C2);  
};  
 Complex::Complex(double r,double i){  
     real = r;imag = i;  
}  
 Complex::Complex(doublr r){  
     real = r; imag = 0;  
}
 Complex::Complex(Complex c1,Complex c2){  
     real = c1.real + c2.real;  
     imag = c1.imag + c2.imag;  
}  
 Complex c1(3),c2(1,0),c3(c1,c2);  
```

8.构造函数在数组中的使用

```
 class Test{  
     public:  
         Test(int n){}      //(1)  
         Test(int n,int m){}//(2)  
         Test(){}           //(3)  
} 

 Test array1[3] = {1,Test(1,2)};    
//三个元素分别用(1)(2)(3)初始化   
 Test array2[3] = {Test(2,3),Test(1,2),1};  
//三个元素分别用(2)(2)(1)初始化  
 Test * pArray[3] = {new Test(4),new Test(1,2)};  
//三个元素分别用(1)(2)初始化   
```

### 

### 复制构造函数\(copy constructor\)

#### 1.基本概念

\(1\)只有一个参数, 即对同类对象的引用.  
\(2\)形如X::X\( X &\)或者X::X\(const X &\) //后者能以常量对象作为参数  
\(3\)若没定义, 编译器生成默认复制构造函数.

```
class Complex{  
    private:  
        double real,imag;  
}  
Complex c1;//调用缺省无参构造函数    
Complex c2(c1);//调用缺省的复制构造函数，将c2初始化为c1;把c1的所有成员变量复制给c2 
```

\(4\)如果定义的自己的复制构造函数, 则默认的复制构造函数不存在.

```
class Complex{  
    public:   
        double real,imag;
    Complex(){}  
    Complex(const Complex &c){  
        real = c.real;  
        imag = c.imag;  
        cout<<"Copy Constructor called";  
    }  
};  
Complex c1;  
Complex c2(c1);  
```

\*注意，只能是本类的引用&, 不允许形如X::X\( X \)的构造函数.

#### 2.复制构造函数起作用的三种情况

\(1\)用一个对象去初始化同类的另一个对象

```
Complex c2(c1);
Complex c2 = c1;//和上面等价, 注意这里是调用了复制构造函数, 是初始化语句, 非赋值语句

c2 = c1;//这是赋值语句, c2已生成, 无需构造函数
```

\(2\)如果某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用。

```
void Func (A a1){}  
int main(){  
    A a2;  
    Func(a2);//若类A的构造函数不是默认的，Func的形参不一定和a2相等    
    return 0;
}  
```

\(3\)如果函数的返回值是类A的对象时，返回时A的复制构造函数被调用

```
class A{  
    public:  
      int v;  
      A(int n){v = n;};  
      A(const A & a){  
          v = a.v;  
          cout<<"Cypy constructor called"<<endl;  
      }  
}  

A Func(){  
    A b(4);  
    return b;  
}  
int main(){  
    A a=Func();  
    cout<<a.v<<endl;  
    return 0;  
}
```

输出结果：

```
Copy constructor called
4
```

#### 3.为什么要自己写复制构造函数?

面向对象有时候必须要自己写复制构造函数，否则会出错  
e.g.

\(1\)reference counting?

\(2\)或者这个类用了一些静态成员函数统计这个类的实例现存的个数:

具体参考后面的静态成员函数/静态成员变量,

在constructor里total\_num++, destructor里total\_num--,

然后再写一个静态成员函数, 就可以统计全局里这个类的存在的实例有多少个.

### 

### 类型转换构造函数

1.

\(1\)目的:实现类型的自动转换

\(2\)特点:

-只有一个参数

-不是复制构造函数

\(3\)编译系统会自动调用 -&gt; 类型转换构造函数 -&gt; 建立一个临时对象/临时变量

```
class Complex{  
    public:  
    double real,imag;  
    Complex(int i){//类型转换构造函数  
        cout<<"intConstructor called"<<endl;  
        real = i; imag = 0;  
    }  
    Complex(double r,double i){  
        real = r; imag = i;      
    }  
};  
int main(){  
    Complex c1(7,8);  
    Complex c2 = 12;//类型转换，对c2进行初始化，不对应生成临时对象  
    c1 = 9; //赋值语句，类型不同，自动调用类型转换，生成临时对象，以9为实参，调用Complex(int i)初始化，将临时对象的值赋值给c1  
    cout<<c1.real<<","<<c1.imag<<endl;  
    return 0;  
}  
```

### 析构函数\(Destructor\)



