## 成员对象\(Member vars\)和封闭类\(Enclosing\)

#### 1.概念

\(1\)成员对象：一个类的成员变量是另一个类的对象  
\(2\)封闭类\(Enclosing\)：包含成员对象的类

#### 2.例子

```
class CTyre{ //轮胎类  
  private:  
    int radius;  
    int width;  
  public: 
    CTyre(int r, int w):radius(r),width(w){} //初始化新方式：初始化列表  
};  

class CEngine{ //引擎类  
}   

class CCar{ //汽车类 -> "封闭类"，包含了成员对象  
  private:  
    int price; //价格  
    CTyre tyre;  
    CEngine engine;  
  public:  
    CCar(int p,int tr,int tw);  
};  
CCar::CCar(int p,int tr,int w):price(p),tyre(tr,w){};  
int main(){  
    CCar car(20000,17,225);  
    return 0;  
}  
```

#### 3.如果CCar类不定义构造函数，则

CCar car; //error, 编译出错  
\(1\)编译器不知道car.tyre该如何初始化  
\(2\)car.engine的初始化没有问题:用默认构造函数  
\(3\)生成封闭类对象的语句-&gt;明确"对象中的成员对象"-&gt;如何初始化

#### 4.封闭类构造函数的初始化列表

\(1\)定义封闭类的构造函数时，添加初始化列表：  
类名::构造函数\(参数表\):成员变量1\(参数表\),成员变量2\(参数表\),...  
{...}  
\(2\)成员对象初始化列表中的参数  
-任意复杂的表达式  
-函数/变量/表达式中的函数,变量有定义

#### 5.调用顺序

当封闭类对象生成时，  
\(1\)执行所有成员对象的构造函数  
\(2\)执行封闭类的构造函数

**成员对象的构造函数调用顺序,            
**\(1\)和成员对象在类中的说明顺序一致  
\(2\)与在成员初始化列表中出现的顺序无关

当封闭类的对象消亡时，  
\(1\)先执行封闭类的析构函数  
\(2\)执行成员对象的析构函数  
\*析构函数顺序和构造函数的调用顺序相反

### 



